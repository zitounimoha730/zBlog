<h1>Kafka AvancÃ© â€“ Rebalance, Offsets, Streams et Design</h1>

<h2>ğŸ”„ Rebalance et Assignors</h2>

<h3>Quâ€™est-ce quâ€™un rebalance ?</h3>
<p>
  Un <strong>rebalance</strong> est une redistribution des partitions entre les consumers dâ€™un mÃªme group.
</p>

<p>Il se produit lorsque :</p>
<ul>
  <li>un consumer dÃ©marre</li>
  <li>un consumer sâ€™arrÃªte ou crash</li>
  <li>le nombre de partitions change</li>
</ul>

<div class="warning">
  Pendant un rebalance, la consommation est temporairement <strong>arrÃªtÃ©e</strong>.
</div>

<h3>Assignors (stratÃ©gies dâ€™attribution)</h3>

<ul>
  <li><strong>RangeAssignor</strong> : partitions contiguÃ«s (dÃ©sÃ©quilibres possibles)</li>
  <li><strong>RoundRobinAssignor</strong> : rÃ©partition uniforme</li>
  <li><strong>StickyAssignor</strong> : minimise les mouvements (recommandÃ©)</li>
  <li><strong>CooperativeStickyAssignor</strong> : rebalance progressif (Kafka rÃ©cent)</li>
</ul>

<div class="note">
  En production moderne, <strong>CooperativeStickyAssignor</strong> est fortement recommandÃ©.
</div>

<h2>ğŸ§  Offsets et Commit</h2>

<h3>Offset</h3>
<p>
  Un <strong>offset</strong> est la position dâ€™un message dans une partition.
</p>

<pre>
Partition P0:
offset 0 | offset 1 | offset 2 | offset 3
</pre>

<p>
  Chaque <strong>consumer group</strong> possÃ¨de ses propres offsets.
</p>

<h3>Commit dâ€™offset</h3>

<ul>
  <li><strong>Auto-commit</strong> : simple mais risquÃ©</li>
  <li><strong>Manual commit</strong> : plus sÃ»r, recommandÃ©</li>
</ul>

<h3>StratÃ©gies de traitement</h3>

<ul>
  <li><strong>At most once</strong> : commit avant traitement (perte possible)</li>
  <li><strong>At least once</strong> : commit aprÃ¨s traitement (doublons possibles)</li>
  <li><strong>Exactly once</strong> : transactions Kafka (Streams)</li>
</ul>

<div class="note">
  Kafka privilÃ©gie naturellement le modÃ¨le <strong>At least once</strong>.
</div>

<h2>ğŸŒŠ Kafka Streams et AgrÃ©gation par ClÃ©</h2>

<h3>Kafka Streams</h3>
<p>
  Kafka Streams est une librairie Java pour le <strong>traitement de flux</strong> directement sur Kafka.
</p>

<ul>
  <li>pas de cluster sÃ©parÃ©</li>
  <li>scalabilitÃ© automatique</li>
  <li>state local + changelog Kafka</li>
</ul>

<h3>Pourquoi la clÃ© est obligatoire ?</h3>

<p>
  Les opÃ©rations suivantes nÃ©cessitent une clÃ© :
</p>

<ul>
  <li>aggregation</li>
  <li>count</li>
  <li>reduce</li>
  <li>join</li>
</ul>

<pre>
KStream
 â†’ groupByKey()
 â†’ aggregate(...)
</pre>

<div class="note">
  La clÃ© dÃ©termine la partition â†’ la tÃ¢che Streams â†’ lâ€™Ã©tat local.
</div>

<h2>âš ï¸ Erreurs Classiques de Design Kafka</h2>

<ul>
  <li>âŒ Trop peu de partitions â†’ pas scalable</li>
  <li>âŒ Mauvaise clÃ© (ex : timestamp)</li>
  <li>âŒ Utiliser Kafka comme une queue classique</li>
  <li>âŒ Changer le nombre de partitions trop tard</li>
  <li>âŒ Auto-commit en production critique</li>
  <li>âŒ Coupler le consumer Ã  la base de donnÃ©es</li>
</ul>

<div class="warning">
  Kafka est un <strong>log distribuÃ©</strong>, pas une simple file FIFO.
</div>

<h2>ğŸ§ª SchÃ©mas Concrets dâ€™Architecture</h2>

<h3>Architecture Event-Driven</h3>

<pre>
Service A
  |
  |-- Event --> Kafka Topic
  |
Service B â”€â”€â”
Service C â”€â”€â”¼â”€ Consumers indÃ©pendants
Service D â”€â”€â”˜
</pre>

<ul>
  <li>faible couplage</li>
  <li>scalabilitÃ© naturelle</li>
  <li>replay possible</li>
</ul>

<h3>CQRS avec Kafka</h3>

<pre>
Command Service
  |
  |-- Command Event --> Kafka
  |
Write Model
  |
  |-- Domain Event --> Kafka
  |
Read Models (multiples projections)
</pre>

<ul>
  <li>sÃ©paration lecture / Ã©criture</li>
  <li>reconstruction de lâ€™Ã©tat possible</li>
  <li>audit et traÃ§abilitÃ©</li>
</ul>

<div class="note">
  Kafka est souvent utilisÃ© comme <strong>backbone event-driven</strong> pour CQRS.
</div>

<h2>Conclusion</h2>
<p>
  Kafka nâ€™est pas seulement un broker de messages :
</p>

<ul>
  <li>câ€™est un <strong>journal distribuÃ©</strong></li>
  <li>une <strong>plateforme dâ€™Ã©vÃ©nements</strong></li>
  <li>un moteur de <strong>stream processing</strong></li>
</ul>

<p>
  Une bonne comprÃ©hension des partitions, clÃ©s, offsets et rebalances
  est essentielle pour un systÃ¨me fiable et scalable.
</p>
